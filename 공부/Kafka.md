# 📡 Kafka
## Kafka 특징

### 1. 빠른 데이터 수집이 가능한 높은 처리량
HTTP 기반으로 전달되는 이벤트일지라도 이벤트가 카프카로 처리되는 응답시간은 불과 한 자릿수의 ms단위로 처리됐습니다. 이를 통해 광범위한 데이터 흐름 도입 가능
### 2. 순서 보장
이벤트 처리 순서가 보장되면서, 엔티티 간의 유효성 검사나 동시 수정 같은 무수한 복잡성 들이 제거됨으로써 구조 또한 매우 간결하다.
### 3. 적어도 한번 전송 방식
분산 네트워크 환경에서 데이터 처리에서 중요한 모범 사례는 **멱등성**입니다. 멱등성이란 동일한 작업을 여러 번 수행하더라도 결과가 달라지지 않는 것을 의미합니다.  
따라서 프로듀서가 재전송을 하더라도 데이터 변화는 일어나지 않습니다. 차선책인 '적어도 한 번' 전송 방식을 사용하더라도 간혹 이벤트들이 중복 발생할 수는 있으나 누락 없는 재전송이 가능하므로 메시지 손실에 대한 걱정이 사라집니다. 또한 백엔드 시스템들이 중복 메시지 처리가 가능하도록 허용된다면 복잡한 트랜잭션 처리가 필요없게 됩니다. 이로인해 아키텍처는 더욱 단순해지고 처리량 또한 높아집니다.
### 4. 자연스러운 백프레셔 핸들링
카프카의 클라이언트는 pull 방식을 사용합니다.  
pull 방식의 장점은 클라이언트 자기 자신의 속도로 데이터를 처리할 수 있다.  
push 방식은 브로커가 보내는 속도에 의존해야 한다는 한계가 있습니다.  
성능과 편리함에 집중하고자 풀 방식을 채탣한 카프카 클라이언트는 복잡한 피드백이나 제한의 요구사항이 사라져 간단하고 편리하게 클라이언트를 구현할 수 있다.
### 5. 강력한 파티셔닝
카프카의 파티셔닝 기능을 이용하면, 논리적으로 토픽을 여러 개로 나눌 수 있습니다. 또한 파티션에 적절한 키를 할당하기 위한 여러 고려사항이 있지만, 각 파티션들을 다른 파티션들과 관계없이 처리할 수 있으므로 효과적인 수평 확장이 가능해졌습니다.
### 6. ETC
로그 컴팩션 기능을 통해 스냅샷 역할이 가능해졌고, 새로운 애플리케이션이 나중에 읽어가는 방식도 문제 없이 처리가능  
프로듀서와 컨슈머가 완벽하게 분리된 비동기 방식을 사용함에 따라 애플리케이션의 병목 현상을 정확하게 파악할 수 있었고, 모니터링을 통해 지연에 대한 문제를 빠르게 해결 가능
  
## 🐬 이벤트 버스 vs 카프카
이벤트 버스 : 개발자가 지정한 개의 컴포넌트 간에 데이터를 주고받을 수 있는 방법 & 이벤트 버스 사용 시 상위-하위 컴포넌트 구조를 유지하지 않아도 다른 컴포넌트로 데이터 전달이 가능하다.
### 이벤트 버스
- 이벤트 버스는 서빙 레이어와 스토리지 레이어가 분리되어 있어 추가적인 홉이 필요하다.
- 이벤트 버스는 fsync()로 블로킹
- 더 많은 하드웨어 자원 필요
### 카프카
- 카프카는 하나의 프로세스에서 스토리지와 요청을 모두 처리
- OS에 의존에 백드라운드로 fsync()를 처리 제로카피를 사용
- 비교적 적은 하드웨어 자원
> [제로카피](https://soft.plusblog.co.kr/) : CPU의 개입을 받지 않고 한 메모리의 영역에서 다른 메모리의 영역으로 데이터를 카피하는 작업을 말한다.  
이는 CPU 사이클을 절약하여서 네트워크나 SSD와 같이 빠른 데이터가 필요한 시스템에서 유용하게 이용된다.



---
참고도서 
> 실전 카프카 개발부터 운영까지 (고영만 지음)

